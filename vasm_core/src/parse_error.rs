use std::fmt::{Display, Formatter};

use vcore::opcodes::InvalidMnemonic;

#[derive(Debug, PartialEq, Clone)]
pub struct Location {
    pub line_num: usize,
    pub file: String,
}

#[derive(Debug, PartialEq, Clone)]
pub enum ParseError {
    LineParseFailure,
    InvalidInstruction(String),
}

impl Display for Location {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{}", self.file, self.line_num)
    }
}

impl Default for Location {
    fn default() -> Self {
        Location {
            line_num: 0,
            file: "<none>".to_string(),
        }
    }
}

impl From<usize> for Location {
    fn from(line: usize) -> Self {
        Self {
            line_num: line,
            file: "<none>".to_string(),
        }
    }
}

impl<'a> From<InvalidMnemonic<'a>> for ParseError {
    fn from(err: InvalidMnemonic<'a>) -> Self {
        Self::InvalidInstruction(err.0.into())
    }
}

impl Display for ParseError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        use ParseError::*;
        match self {
            LineParseFailure => write!(f, "Failed to parse line"),
            InvalidInstruction(p) => write!(f, "Cannot parse {} as instruction", p),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum AssembleError {
    ParseError(Location, ParseError),
    EquResolveError(Location, String, EvalError),
    EquDuplicateError(Location, String),
    OrgResolveError(Location, EvalError),
    ArgError(Location, EvalError),
    NoCode,
    IncludeError(Location, String),
    FileError(String),
    MacroError(Location),
}

impl Display for AssembleError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            AssembleError::EquResolveError(line, name, err) => {
                write!(f, "Cannot resolve .equ {} at {}: {}", name, line, err)
            }
            AssembleError::EquDuplicateError(line, name) => {
                write!(f, "Duplicate .equ {} at {}", name, line)
            }
            AssembleError::OrgResolveError(line, err) => {
                write!(f, "Cannot resolve .org at {}: {}", line, err)
            }
            AssembleError::ArgError(line, err) => {
                write!(f, "Cannot calculate argument at {}: {}", line, err)
            }
            AssembleError::NoCode => {
                write!(f, "No output would be generated by this code")
            }
            AssembleError::ParseError(line, err) => {
                write!(f, "Parse error at {}: {}", line, err)
            }
            AssembleError::IncludeError(line, file) => {
                write!(f, "Cannot read \"{}\" at {}", file, line)
            }
            AssembleError::MacroError(line) => {
                write!(f, "Malformed macro control structure at {}", line)
            }
            AssembleError::FileError(file) => {
                write!(f, "File read error in {}", file)
            }
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum EvalError {
    MissingLabel(String),
    UnknownAddress(usize),
    OffsetError(usize, i32),
}

impl Display for EvalError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            EvalError::MissingLabel(label) => write!(f, "Unable to resolve label {}", label),
            EvalError::UnknownAddress(line_num) => write!(
                f,
                "Unable to calculate starting address of line {}",
                line_num
            ),
            EvalError::OffsetError(line_num, offset) => {
                write!(f, "Invalid line offset {} on line {}", offset, line_num)
            }
        }
    }
}
